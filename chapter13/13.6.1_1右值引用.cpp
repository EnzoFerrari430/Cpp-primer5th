#include <iostream>
using namespace std;
/*
有些类(如IO类，unique_ptr这样的类，里面都包含了不能被共享的资源，因此这些类的对象不能被拷贝但可以移动)
    在旧版本的标准库中，容器保存的类型必须是可以拷贝的。
    在新版本的标准库中，可以用容器保存不可拷贝的类型，只要它们可以被移动即可


我们通过&&来获得右值引用，普通的引用称之为左值引用
右值引用的一个重要特性-只能绑定到一个将要销毁的对象身上,因此我们可以自由的将一个右值引用资源“移动”到另一个对象中去

*/

void f(int &i)
{
    cout<<"lvalue ref: "<<i<<endl;
}

void f(int &&i)
{
    cout<<"rvalue ref: "<<i<<endl;
}

//return ii；  ii表达式只是一个短暂的对象，所以该表达式是右值
int getValue()
{
    int ii = 11;
    return ii;
}

//返回左引用的函数，连同赋值、下标、解引用、前置递增/递减都是返回左引用表达式的例子
int &foo(int &i)
{
    i = i + 10;
    return i;
}

//返回非引用类型的函数，连同算术，关系，位以及后置递增递减都生成右值
int foo2( int i )
{
    i = i + 10;
    return i;
}

/*
    左值表达式和右值表达式的区别：
        左值有持久的状态，右值要么是字面常量，要么是表达式在求值过程中创建的临时变量

    由于右值引用的这种特性：
        所引用的对象将要被销毁
        该对象没有其他用户
    这2种特性意味着：使用右值引用的代码可以自由接管所引用的对象的资源
*/

int main()
{
    int i = 42;
    int &r = i;  //正确引用i
    //int &&rr = i;  //没有运算符号的表达式都是左值
    //int &r2 = i * 42;  //表达式的结果是一个短暂的对象，该表达式是右值  ( 一个非常量 * 一个常量  返回的结果变成了一个常量 )
    const int &r3 = i * 42;  //const的引用可以绑定到右值上,但是该引用不能修改值
    //r3 = 100;  //r3只能读
    int &&rr2 = i * 42;


    int ii = 77;
    f(ii);  //调用左值
    f(10*ii);  // !!!调用右值 ( 一个非常量 * 一个常量  返回的结果变成了一个常量 )
    f(99);  //调用右值


    //int &g1 = getValue();  //可以看出返回ii是短暂表达式，所以是右值
    int &&gg1 = getValue();


    int fi = 10;
    ++foo(fi);
    cout<<fi<<endl;

    int fi2 = 10;
    int &&ffi2 = foo2(fi2)<<1;
    cout<<fi2<<endl;
    cout<<ffi2<<endl;

    int &&rrr1 = 42;
    //int &&rrr2 = rrr1;  //rrr1是变量表达式，变量表达式都是左值。也能看的出来这个rrr1是持久的

    return 0;
}
