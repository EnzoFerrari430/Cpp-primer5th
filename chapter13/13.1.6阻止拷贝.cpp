#include <iostream>
using namespace std;
/*
    有些类的拷贝构造函数和拷贝赋值运算符是没有合理的意义的，在此情况下，定义类必须采用某种机制阻止拷贝或赋值

    定义删除的函数，在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。
    删除的函数是一种函数：虽然声明了它们，但不能以任何方式使用它们。

    =delete必须出现在第一次声明的时候

*/

struct NoCopy
{
    NoCopy() = default;  //使用合成的默认构造函数
    NoCopy(const NoCopy&) = delete;  //阻止拷贝
    NoCopy &operator=(const NoCopy&) = delete;  //阻止赋值
    ~NoCopy() = default;  //使用合成的析构函数
};

//对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象，但是不能释放这些对象
struct NoDtor
{
    NoDtor() = default;  //使用默认的合成构造函数
    ~NoDtor() = delete;  //不能销毁NoDtor类型的对象
};


/*

对某些类来说，编译器将这些合成的成员定义为删除的函数：
    如果类的某个成员的析构函数是删除的或不可访问的（比如是private的），则类的合成的析构函数被定义为删除的

    如果类的某个成员的拷贝构造函数是删除的或者不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或者
    不可访问的，则类合成的拷贝构造函数也被定义为删除的

    如果类的某个成员的拷贝赋值运算符是删除的或者不可访问的，或者类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的

    如果类的某个成员的析构函数是删除的或不可访问的，或者类有一个引用成员，它没有类内初始化器，或者类有一个const成员，它没有类内初始化器
    且其类型未显示定义默认构造函数，则该类的默认构造函数被定义为删除的。

总结：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的

    具有引用成员或无法默认构造的const成员的类，编译器不会为其合成默认构造函数，如果一个类有const成员，则它不能使用合成的拷贝赋值运算符，
    毕竟这个运算符试图赋值所有成员，而将一个新值赋予一个const对象是不可能的。

    对于引用成员，如果使用合成拷贝赋值运算符，则赋值后，左侧运算对象任然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。
    这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

*/

int main()
{
    //NoDtor = nd;
    NoDtor *p = new NoDtor();
    //delete p;  析构函数是删除的


    return 0;
}
