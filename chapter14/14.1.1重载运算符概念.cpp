#include <iostream>
#include <string>
using namespace std;


/*
    1.二元运算符，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数
    2.除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参
    3.如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象会被绑定到隐式的this指针上，造成成员运算符的参数数量要比运算符的总对象少一个。
    4.运算符函数的运算对象不能全是内置类型
    5.我们只能重载已有的运算符，而无权发明新的运算符号
    6.一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致
    7.将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数（只是看着很傻比）
        data1 + data2  普通的表达式
        operator+ (data1,data2)  等价的函数调用
    8.有些运算符不应该被重载
        关于运算对象的求值顺序的规则无法应用到重载的运算符操作上。  逻辑与运算符，逻辑或运算符，逗号运算符
        && 和 || 运算符的重载版本也无法保留内置运算符的短路径求值属性，2个运算对象总是会被求值

    9.在确定类需要哪些操作之后，才能思考到底应该把每个类的操作设计成普通函数还是重载的运算符。
        如果某些操作在逻辑上与运算符相关，则它们适合于定义成重载的操作符

    10.赋值运算符的行为和复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，而且运算符应该返回它左侧对象的引用
*/

//  11.如果想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数
//      如果把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。
string s = "world";
string t = s + "!";  //正确：我们能把一个const char*  加到一个string对象中
string u = "hi" + s;  //如果+是string的成员，则产生错误
因为"hi"的类型是const char*，是内置类型，根本就没有成员函数
所以string将+定义成了普通的非成员函数，"hi" + s等价于operator+("hi" ,s) 每个实参都能被转换成形参类型。唯一的要求就是至少有一个运算对象是类类型，并且2个运算对象都能准确无误的转换成string
int main()
{

    return 0;
}
