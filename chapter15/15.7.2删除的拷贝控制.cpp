#include <iostream>
using namespace std;
/*
定义基类的方式导致派生类成员成为被删除的函数
1.基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的，则派生类中对应的成员将是被删除的。
2.基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的。
3.如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的。（这点不是很理解）
*/

class B
{
public:
    B(){}
    B(const B&) = delete;

    virtual ~B() = default;
};

class D:public B
{
public:
    //D();
};
int main()
{
    D d;
    //D d2(d);  //基类的拷贝构造函数是删除的，所以派生类的合成的拷贝构造函数也是删除的
    //D d3(std::move(d));  //基类定义了析构函数，所以编译器不会定义合成的移动构造函数，这里使用的还是拷贝构造函数

    return 0;
}
